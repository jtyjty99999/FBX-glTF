//
// Copyright (c) Autodesk, Inc. All rights reserved 
//
// C++ glTF FBX importer/exporter plug-in
// by Cyrille Fauvel - Autodesk Developer Network (ADN)
// January 2015
//
// Permission to use, copy, modify, and distribute this software in
// object code form for any purpose and without fee is hereby granted, 
// provided that the above copyright notice appears in all copies and 
// that both that copyright notice and the limited warranty and
// restricted rights notice below appear in all supporting 
// documentation.
//
// AUTODESK PROVIDES THIS PROGRAM "AS IS" AND WITH ALL FAULTS. 
// AUTODESK SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR USE.  AUTODESK, INC. 
// DOES NOT WARRANT THAT THE OPERATION OF THE PROGRAM WILL BE
// UNINTERRUPTED OR ERROR FREE.
//
#pragma once

#define _USE_MATH_DEFINES
#include <math.h>
#include "jsoncpp/json.h"

#define FBX_GLTF_EXPORTER ("FBX GLTF Exporter v1.0")
#define PROFILE_API ("WebGL")
#define PROFILE_VERSION ("1.0.3")
#define GLTF_VERSION ("1.0")

#define DEG2RAD(a) a * M_PI / 180.0
#define MergeJsonObjects_(a, b) \
	for ( const auto &iter : b.as_object () ) \
		a [iter.first] =iter.second
//#define MergeJsonFromRetObject(a, b) \
//	{ \
//	Json::Value b2 =b ; \
//	for ( const auto &iter : b2.as_object () ) \
//		a [iter.first] =iter.second ; \
//	}

#define GLTF_ANGLE(a) \
	GetIOSettings ()->GetBoolProp (IOSN_FBX_GLTF_ANGLEINDEGREE, false) ? a : DEG2RAD(a)

namespace _IOglTF_NS_ {

Json::Value &MergeJsonObjects (Json::Value &a, const Json::Value &b) ;
std::string GetJsonObjectKeyAt (Json::Value &a, int i =0) ;
#define GetJsonFirstKey(a) GetJsonObjectKeyAt(a)

class gltfWriter : public FbxWriter {
private:
	std::string _fileName ;
	std::ofstream _gltf ;
	memoryStream<uint8_t> _bin ;

	Json::Value _json ;

	bool _writeDefaults ;
	double _samplingPeriod ;
	std::map<FbxUInt64, std::string> _IDs ;
	std::vector<std::string> _registeredNames ;
	std::map<std::string, std::string> _uvSets ;
#ifdef _DEBUG
	std::vector<std::string> _path ;
#endif

public:
	gltfWriter (FbxManager &pManager, int id) ;
	virtual ~gltfWriter () ;

	virtual bool FileCreate (char *pFileName) ;
	virtual bool FileClose () ;
	virtual bool IsFileOpen () ;
	virtual void GetWriteOptions () ;
	virtual bool Write (FbxDocument *pDocument) ;
	virtual bool PreprocessScene (FbxScene &scene) ;
	virtual bool PostprocessScene (FbxScene &scene) ;

	static FbxWriter *Create_gltfWriter (FbxManager &manager, FbxExporter &exporter, int subID, int pluginID) ;
	static void *gltfFormatInfo (FbxWriter::EInfoRequest request, int id) ;
	static void FillIOSettings (FbxIOSettings &ios) ;

protected:
	void PrepareForSerialization () ;

protected:
	bool recordId (FbxUInt64 uniqid, std::string id) ;
	bool isKnownId (FbxUInt64 uniqid) ;
	bool isKnownId (std::string id) ;
public:
	std::string nodeId (FbxNode *pNode, bool bNodeAttribute =false, bool bRecord =false) ;

protected:
	std::string registerName (std::string name) ;
	bool isNameRegistered (std::string id) ;
public:
	std::string createUniqueName (std::string type, FbxUInt64 id) ;

	inline std::string createSamplerName (FbxString &szname) { return (("sampler_") + std::string(szname.Buffer ())) ; }
	inline std::string createSamplerName (const char *pszName) { return (("sampler_") + std::string(pszName)) ; }
	inline std::string createTextureName (FbxString &szname) { return (("texture_") + std::string(szname.Buffer ())) ; }
	inline std::string createTextureName (const char *pszName) { return (("texture_") + std::string(pszName)) ; }

protected:
	Json::Value WriteSceneNodeRecursive (FbxNode *pNode, FbxPose *pPose =nullptr, bool bRoot =false) ;
	Json::Value WriteSceneNode (FbxNode *pNode, FbxPose *pPose =nullptr) ;
	FbxNodeAttribute::EType nodeType (FbxNode *pNode) ;

	bool IsGeometryNode (FbxNode *pNode) ;
	bool CheckMaterials (FbxNode *pNode) ;
	void PreprocessNodeRecursive (FbxNode *pNode) ;
	Json::Value WriteNode (FbxNode *pNode) ;
	Json::Value GetTransform (FbxNode *pNode) ;

	// The following list is json nodes generated by other json nodes
	// accessor / bufferView

	// asset
	bool WriteAsset (FbxDocumentInfo *pSceneInfo) ;
	// buffer
	bool WriteBuffer () ;
	// camera
	double cameraYFOV (FbxCamera *pCamera) ;
	Json::Value WriteCamera (FbxNode *pNode) ;
	// light
	void lightAttenuation (FbxLight *pLight, Json::Value &lightDef) ;
	Json::Value WriteLight (FbxNode *pNode) ;
	Json::Value WriteAmbientLight (FbxScene &pScene) ;
	// material
	std::string LighthingModel (FbxSurfaceMaterial *pMaterial) ;
	Json::Value WriteMaterialTransparencyParameter (const char *pszName, FbxPropertyT<FbxDouble> &property, FbxPropertyT<FbxDouble3> &propertyColor, FbxProperty &propertyOpaque, Json::Value &values, Json::Value &techniqueParameters) ;
	//Json::Value WriteMaterialTransparencyParameter (const char *pszName, FbxPropertyT<FbxDouble> &property, Json::Value &values, Json::Value &techniqueParameters) ;
	Json::Value WriteMaterialParameter (const char *pszName, FbxPropertyT<FbxDouble3> &property, double factor, Json::Value &values, Json::Value &techniqueParameters) ;
	Json::Value WriteMaterialParameter (const char *pszName, FbxPropertyT<FbxDouble> &property, Json::Value &values, Json::Value &techniqueParameters) ;
	Json::Value WriteMaterialParameter (const char *pszName, FbxSurfaceMaterial *pMaterial, const char *propertyName, const char *factorName, Json::Value &values, Json::Value &techniqueParameters) ;
	Json::Value WriteMaterial (FbxNode *pNode, FbxSurfaceMaterial *pMaterial) ;
	Json::Value WriteDefaultMaterial (FbxNode *pNode) ;
	Json::Value WritePhongMaterial (FbxNode *pNode, FbxSurfaceMaterial *pMaterial) ;
	Json::Value WriteLambertMaterial (FbxNode *pNode, FbxSurfaceMaterial *pMaterial) ;
	Json::Value WriteConstantShadingModelMaterial (FbxNode *pNode, FbxSurfaceMaterial *pMaterial) ;
	Json::Value WriteBlinnShadingModelMaterial (FbxNode *pNode, FbxSurfaceMaterial *pMaterial) ;
	Json::Value WriteDefaultShadingModelWithCGFXMaterial (FbxNode *pNode, FbxSurfaceMaterial *pMaterial) ;
	Json::Value WriteDefaultShadingModelMaterial (FbxNode *pNode, FbxSurfaceMaterial *pMaterial) ;
	Json::Value WriteDefaultShadingModelMaterial (FbxNode *pNode) ;
	// mesh
	Json::Value WriteMesh (FbxNode *pNode) ;
	// line
	//Json::Value WriteLine (FbxNode *pNode) ;
	// null
	Json::Value WriteNull (FbxNode *pNode) ;
	// program
	Json::Value WriteProgram (FbxNode *pNode, FbxSurfaceMaterial *pMaterial, std::string programName, Json::Value &attributes) ;
	// scenes / scene
	bool WriteScene (FbxScene *pScene, int poseIndex =-1) ;
	// shaders
	Json::Value WriteShaders (FbxNode *pNode, Json::Value &program) ;
	// technique
	void AdditionalTechniqueParameters (FbxNode *pNode, Json::Value &techniqueParameters, bool bHasNormals =false) ;
	void TechniqueParameters (FbxNode *pNode, Json::Value &techniqueParameters, Json::Value &attributes, Json::Value &accessors, bool bHasMaterial =true) ;
	Json::Value WriteTechnique (FbxNode *pNode, FbxSurfaceMaterial *pMaterial, Json::Value &techniqueParameters) ;
	// textures
	Json::Value WriteTextureBindings (FbxMesh *pMesh, FbxSurfaceMaterial *pMaterial, Json::Value &params) ;
	Json::Value WriteTexture (FbxTexture *pTexture) ;

	// buffer
	bool WriteShaders () ;

private:
	typedef Json::Value (gltfWriter::*ExporterRouteFct) (FbxNode *pNode) ;
	typedef std::map<FbxNodeAttribute::EType, ExporterRouteFct> ExporterRoutes ;
	static ExporterRoutes _routes ;

	template<class Type /*, const char *Type*/>
	Json::Value WriteArray (std::vector<Type> &data, int size, FbxNode *pNode, const char *suffix) ;
	template<class T, class Type /*, const char *Type*/>
	Json::Value WriteArray (FbxArray<T> &data, FbxNode *pNode, const char *suffix) ;
	template<class T, class Type /*, const char *Type*/>
	Json::Value WriteArray (std::vector<T> &data, FbxNode *pNode, const char *suffix) ;

	template<class T, class Type /*, const char *Type*/>
	Json::Value WriteArrayWithMinMax (FbxArray<T> &data, FbxNode *pNode, const char *suffix) ;
	template<class T, class Type /*, const char *Type*/>
	Json::Value WriteArrayWithMinMax (std::vector<T> &data, FbxNode *pNode, const char *suffix) ;
	template<class T, class Type /*, const char *Type*/>
	Json::Value WriteArrayWithMinMax (FbxArray<T> &data, T bMin, T bMax, FbxNode *pNode, const char *suffix) ;
	template<class T, class Type /*, const char *Type*/>
	Json::Value WriteArrayWithMinMax (std::vector<T> &data, T bMin, T bMax, FbxNode *pNode, const char *suffix) ;

} ;

//-----------------------------------------------------------------------------
template<class Type>
Json::Value gltfWriter::WriteArray (std::vector<Type> &data, int size, FbxNode *pNode, const char *suffix) {
	std::ofstream::pos_type offset =_bin.tellg () ;
	//std::copy (data.begin (), data.end (), std::ostream_iterator<Type> (_bin)) ;
#if defined(_WIN32) || defined(_WIN64)
	for ( std::vector<Type>::iterator iter =data.begin () ; iter != data.end () ; iter++ )
		_bin.write ((uint8_t *)&(*iter), sizeof (Type)) ;
#else
	typedef typename std::vector<Type>::iterator iteratorType ;
	for ( iteratorType iter =data.begin () ; iter != data.end () ; iter++ )
		_bin.write ((uint8_t *)&(*iter), sizeof (Type)) ;
#endif
	// bufferView
	Json::Value viewDef( Json::objectValue ) ;
	FbxString filename =FbxPathUtils::GetFileName (_fileName.c_str (), false) ;
	viewDef [("buffer")] =filename.Buffer () ;
	size_t nb =data.size () / size ;
	viewDef [("byteLength")] =((int)(sizeof (Type) * nb * size)) ;
	viewDef [("byteOffset")] =((int)offset) ;
	// Array buffers (ARRAY_BUFFER) : These buffers contain vertex attributes, such as vertex coordinates, texture coordinate data,
	// per vertex - color data, and normals.They can be interleaved (using the stride parameter) or sequential, with one array after
	// another (write 1, 000 vertices, then 1, 000 normals, and so on).glVertexPointer and glNormalPointer each point to the appropriate offsets.
	// Element array buffers (ELEMENT_ARRAY_BUFFER) : This type of buffer is used mainly for the element pointer in glDraw [Range]Elements ().
	// It contains only indices of elements.
	viewDef [("target")] =size == 1 ? IOglTF::ELEMENT_ARRAY_BUFFER : IOglTF::ARRAY_BUFFER ; // Valid values are 34962 (ARRAY_BUFFER) or 34963 (ELEMENT_ARRAY_BUFFER)
	viewDef [("name")] =nodeId (pNode, true) + suffix + ("_Buffer") ;
	Json::Value view;
	view[nodeId (pNode, true) + suffix + ("_Buffer")] = viewDef ;

	// Accessor
	Json::Value accDef ;
	accDef [("bufferView")] =(nodeId (pNode, true) + suffix + ("_Buffer")) ;
	accDef [("byteOffset")] =((int)0) ;
	accDef [("byteStride")] =(/*size == 1 ? 0 :*/ (int)sizeof (Type) * size) ;
	accDef [("componentType")] =((int)IOglTF::accessorComponentType<Type> ()) ;
	accDef [("count")] =((int)nb) ;
	//accDef [("min")] =Json::Value::array ({ { (float)bMin.Buffer () [0], (float)bMin.Buffer () [1], (float)bMin.Buffer () [2] } }) ;
	//accDef [("max")] =Json::Value::array ({ { (float)bMax.Buffer () [0], (float)bMax.Buffer () [1], (float)bMax.Buffer () [2] } }) ;
	accDef [("type")] =(IOglTF::accessorType<Type> (size, 1)) ;
	accDef [("name")] =(nodeId (pNode, true) + suffix) ;
	Json::Value acc;
	acc[nodeId (pNode, true) + suffix] = accDef ;
	
	Json::Value ret;
	ret["accessors"] = acc;
	ret["bufferViews"] = view;
	return ret ;
}

template<class T, class Type>
Json::Value gltfWriter::WriteArray (FbxArray<T> &data, FbxNode *pNode, const char *suffix) {
	// glTF/Collada do not support double, convert to float (or Type)
	int size =sizeof (decltype(std::declval<T> ().mData)) / sizeof (decltype(std::declval<T> ().mData [0])) ;
	int nb =data.GetCount () ;
	std::vector<Type> fdata (nb * size) ;
	for ( int i =0 ; i < nb ; i++ )
		for ( int j =0 ; j < size ; j++ )
			fdata [i * size + j] =(Type)data [i].Buffer () [j] ;

	return (WriteArray<Type> (fdata, size, pNode, suffix)) ;
}

template<class T, class Type>
Json::Value gltfWriter::WriteArray (std::vector<T> &data, FbxNode *pNode, const char *suffix) {
	// glTF/Collada do not support double, convert to float (or Type)
	int size =sizeof (decltype(std::declval<T> ().mData)) / sizeof (decltype(std::declval<T> ().mData [0])) ;
	int nb =(int)data.size () ;
	std::vector<Type> fdata (nb * size) ;
	for ( int i =0 ; i < nb ; i++ )
		for ( int j =0 ; j < size ; j++ )
			fdata [i * size + j] =(Type)data [i] [j] ;
	return (WriteArray<Type> (fdata, size, pNode, suffix)) ;
}

template<class T, class Type>
Json::Value gltfWriter::WriteArrayWithMinMax (FbxArray<T> &data, FbxNode *pNode, const char *suffix) {
	int nb =data.GetCount () ;
	std::vector<T> fdata (nb) ;
	for ( int i =0 ; i < nb ; i++ )
		fdata [i] =data [i] ;
	return (WriteArrayWithMinMax<T, Type> (fdata, pNode, suffix)) ;
}

template<class T, class Type>
Json::Value gltfWriter::WriteArrayWithMinMax (std::vector<T> &data, FbxNode *pNode, const char *suffix) {
	int size =sizeof (decltype(std::declval<T> ().mData)) / sizeof (decltype(std::declval<T> ().mData [0])) ;
#pragma push_macro ("min")
#undef min
#pragma push_macro ("max")
#undef max
	T bMin ;
	for ( int i =0 ; i < size ; i++ )
		bMin [i] =std::numeric_limits<double>::max () ; // DBL_MAX
	T bMax ;
	for ( int i =0 ; i < size ; i++ )
		bMax [i] =std::numeric_limits<double>::min () ; // DBL_MIN
	int nb =(int)data.size () ;
	for ( int i =0 ; i < nb ; i++ ) {
		for ( int j =0 ; j < size ; j++ ) {
			bMin [j] =std::min (bMin [j], data [i] [j]) ;
			bMax [j] =std::max (bMax [j], data [i] [j]) ;
		}
	}
#pragma pop_macro ("min")
#pragma pop_macro ("max")
	return (WriteArrayWithMinMax<T, Type> (data, bMin, bMax, pNode, suffix)) ;
}

template<class T, class Type>
Json::Value gltfWriter::WriteArrayWithMinMax (FbxArray<T> &data, T bMin, T bMax, FbxNode *pNode, const char *suffix) {
	int nb =data.GetCount () ;
	std::vector<T> fdata (nb) ;
	for ( int i =0 ; i < nb ; i++ )
		fdata [i] =data [i] ;
	return (WriteArrayWithMinMax<T, Type> (fdata, bMin, bMax, pNode, suffix)) ;
}

template<class T, class Type>
Json::Value gltfWriter::WriteArrayWithMinMax (std::vector<T> &data, T bMin, T bMax, FbxNode *pNode, const char *suffix) {
	Json::Value ret =WriteArray<T, Type> (data, pNode, suffix) ;
	Json::Value accDef =ret [("accessors")] [GetJsonFirstKey (ret [("accessors")])] ;
	//accDef [("min")] =Json::Value::array ({ { (float)bMin.Buffer () [0], (float)bMin.Buffer () [1], (float)bMin.Buffer () [2] } }) ;
	//accDef [("max")] =Json::Value::array ({ { (float)bMax.Buffer () [0], (float)bMax.Buffer () [1], (float)bMax.Buffer () [2] } }) ;
	int size =sizeof (decltype(std::declval<T> ().mData)) / sizeof (decltype(std::declval<T> ().mData [0])) ;
	for ( int j =0 ; j < size ; j++ )
		accDef [("min")] [j] =(Type)bMin.Buffer () [j] ;
	for ( int j =0 ; j < size ; j++ )
		accDef [("max")] [j] =(Type)bMax.Buffer () [j] ;
	ret [("accessors")] [GetJsonFirstKey (ret [("accessors")])] =accDef ;
	return (ret) ;
}

}
